<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Pantry</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
      <!-- <h1>Welcome to Pixel Pantry</h1> -->
  </header>
  <main>
    <div id="toolbar">
      <label for="colorPicker">Choose Color:</label>
      <div id="colorDisplay"><!--  Color options added here  --></div>
    </div>
    <button id="saveButton" disabled onclick="savePixels()">Loading...</button>
    <button id="cancelButton" onclick="cancelPixels()" style="display: none;">
      &#10006;<!--  âœ–  -->
    </button>
    <canvas id="pixelCanvas" width="1000" height="1000"></canvas>
  </main>
</body>
<script>
const canvas = document.getElementById('pixelCanvas');
const ctx = canvas.getContext('2d');
const GRID_SIZE = 100;
const PIXEL_SIZE = canvas.width / GRID_SIZE;


let hoveredPixel = null; // Hover pixel tracking
let selectedColor = `hsl(0, 0%, 0%)`; // color to draw, default black
let totalPainted = 0; // Total pixels painted, out of 10 limit
let timeout = 0;
let userPixels = []; // pixels painted by user
let saved = false; // recently saved by the user

// Initialize grid
let grid = [];
for (let y = 0; y < GRID_SIZE; y++) {
  for (let x = 0; x < GRID_SIZE; x++) {
    grid.push({
      x: x,
      y: y,
      color: '#FFFFFF' // default white
    })
  }
}

// Draw a pixel on the canvas
drawPixel = (x, y, color) => {
  ctx.fillStyle = color;
  ctx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
}

// Get pixel color at coordinates
function getPixelColor(x, y) {
  const userPixel = userPixels.find(p => p.x === x && p.y === y);
  if (userPixel) {
    return userPixel.color;
  }
  const gridPixel = grid.find(p => p.x === x && p.y === y);
  return gridPixel ? gridPixel.color : -1;
}

// Load from DataPantry on init
async function loadCanvas() {
  const res = await fetch('/api/load-pixels').then(r => r.json())
  console.log('Loaded pixel data:', res.pixels.length, 'records. Sample:', res.pixels.slice(0, 5));
  console.log('User wait time (seconds):', res.waitTime);
  res.pixels.forEach(pixel => {
    const index = grid.findIndex(p => p.x === pixel.x && p.y === pixel.y);
    if (index !== -1) {
      grid[index].color = pixel.color;
    }
  })
  timeout = res.waitTime || 0;
  redrawCanvas();
  startTimeoutTimer();
}

// Redraw entire canvas
function redrawCanvas() {
  grid.forEach(pixel => {
    drawPixel(pixel.x, pixel.y, pixel.color);
  });
}


//  hover effect
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect()
  const x = Math.floor((e.clientX - rect.left) / PIXEL_SIZE)
  const y = Math.floor((e.clientY - rect.top) / PIXEL_SIZE)
  
  if (hoveredPixel?.x !== x || hoveredPixel?.y !== y) {
    // Redraw old hovered pixel (remove outline)
    let color = getPixelColor(x, y);
    if (hoveredPixel) {
      let userPixel = userPixels.find(p => p.x === hoveredPixel.x && p.y === hoveredPixel.y);
      if (userPixel) {
        drawPixel(hoveredPixel.x, hoveredPixel.y, userPixel.color)
      } else {
        let gridIndex = grid.findIndex(p => p.x === hoveredPixel.x && p.y === hoveredPixel.y);
        if (gridIndex === -1) return; // out of bounds
        drawPixel(hoveredPixel.x, hoveredPixel.y, grid[gridIndex].color)
      }
    }
    
    // Draw new hover outline
    hoveredPixel = { x, y }
    let gridIndex = grid.findIndex(p => p.x === x && p.y === y);
    if (gridIndex === -1) return; // out of bounds
    drawPixel(x, y, grid[gridIndex].color)
    ctx.strokeStyle = '#000000'
    ctx.lineWidth = 2
    ctx.strokeRect(x * PIXEL_SIZE + 1, y * PIXEL_SIZE + 1, PIXEL_SIZE-2, PIXEL_SIZE-2)
  }
})

// mouse out
canvas.addEventListener('mouseout', (e) => {
  if (hoveredPixel) {
    drawPixel(hoveredPixel.x, hoveredPixel.y, grid[hoveredPixel.y][hoveredPixel.x])
    hoveredPixel = null;
  }
});

//  draw on click
canvas.addEventListener('click', async (e) => {
  if (!hoveredPixel || totalPainted >= 10 || timeout > 0) return;
  const { x, y } = hoveredPixel;
  userPixels.push({ x, y, color: selectedColor });
  drawPixel(x, y, selectedColor);
  totalPainted++;
  document.getElementById('saveButton').disabled = false;
  document.getElementById('saveButton').innerText = `Save ${totalPainted}/10 Pixels`;
  document.getElementById('cancelButton').style.display = 'flex';
  return;
  // Save to DataPantry
  
});

// Start timeout timer
function startTimeoutTimer() {
  let countdown = setInterval(() => {
    timeout--;
    if (timeout <= 0) {
      document.getElementById('saveButton').innerText = `Save 0/10 Pixels`;
      clearInterval(countdown);
      saved = false;
    } else {
      document.getElementById('saveButton').innerText = `${saved ? 'Saved!' : ''} Wait ${Math.floor(timeout / 60)}:${(timeout % 60).toString().padStart(2, '0')} min`;
    }
  }, 1000); // 1 second
}

// Save pixels to server
async function savePixels() {
  document.getElementById('saveButton').innerText = `Saving...`;
  console.log('Saving pixels:', userPixels);
  // return;
  timeout = 5 * 60; // 5 minutes in seconds
  const response = await fetch('/api/save-pixel', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      pixels: userPixels
    })
  });
  if (response.status !== 200) {
    const errorText = await response.text();
    alert(`Error saving pixels: ${errorText}`);
    document.getElementById('saveButton').innerText = `Save ${totalPainted}/10 Pixels`;
    return;
  }
  totalPainted = 0;
  document.getElementById('saveButton').innerText = `Saved! Wait 5:00 min`;
  document.getElementById('saveButton').disabled = true;
  saved = true;
  startTimeoutTimer();
} 

function cancelPixels() {
  userPixels = [];
  totalPainted = 0;
  document.getElementById('saveButton').innerText = `Save 0/10 Pixels`;
  document.getElementById('saveButton').disabled = true;
  document.getElementById('cancelButton').style.display = 'none';
  redrawCanvas();
}

// Get an array of colors for the color options
function getColorArray() {
  const colors = [];
  for (let l = 0; l <= 100; l += 20) {   // 6 Grays
    colors.push(`hsl(0, 0%, ${l}%)`);
  }
  for (let h = 0; h < 360; h += 60) { //  6 Hues
    for (let s = 100; s >= 20; s -= 40) {  // 3 Saturations
      for (let l = 25; l <= 80; l += 25) {   // 3 Lightness
        colors.push(`hsl(${h}, ${s}%, ${l}%)`);
      }
    }
  }
  return colors;

}

function populateColorOptions() {
  const colorDisplay = document.getElementById('colorDisplay')
  colorDisplay.innerHTML = '' // clear existing
  const colors = getColorArray();
  colors.forEach(color => {
    const colorDiv = document.createElement('div')
    colorDiv.className = 'colorOption'
    colorDiv.className += (color === selectedColor) ? ' selected' : ''
    colorDiv.style.backgroundColor = color
    colorDiv.addEventListener('click', () => {
      selectedColor = color
      populateColorOptions() // refresh to show selected
    })

    colorDisplay.appendChild(colorDiv)
  })
}

function mount() {
  loadCanvas()
  redrawCanvas();
  populateColorOptions();
}
mount();
</script>
</html>