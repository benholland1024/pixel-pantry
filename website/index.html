<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Pantry</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
      <!-- <h1>Welcome to Pixel Pantry</h1> -->
  </header>
  <main>
    <div id="toolbar">
      <label for="colorPicker">Choose Color:</label>
      <div id="colorDisplay"><!--  Color options added here  --></div>
    </div>
    <button id="saveButton" disabled onclick="savePixels()">Loading...</button>
    <button id="cancelButton" onclick="cancelPixels()" style="display: none;">
      &#10006;<!--  âœ–  -->
    </button>
    <canvas id="pixelCanvas"></canvas>
  </main>
</body>

<script>

const canvas = document.getElementById('pixelCanvas');
const ctx = canvas.getContext('2d');
canvas.width = 1000;
canvas.height = 1000;
const GRID_SIZE = 100;
const PIXEL_SIZE = canvas.width / GRID_SIZE;
const MAX_DRAW_PER_SESSION = 10;

let hoveredPixel = null; // Hover pixel tracking
let selectedColor = `hsl(0, 0%, 0%)`; // color to draw, default black
let totalPainted = 0; // Total pixels painted, out of 10 limit
let timeout = 0;
let userPixels = []; // pixels painted by user
let saved = false; // recently saved by the user
let zoom = 1;
let pan = {
  x: (window.innerWidth - canvas.width) / 2, // Start centered
  y: 0
};
let mousedown = false;
let previousMousePos = {
  x: 0,
  y: 0 
};

// Initialize grid
let grid = [];
for (let y = 0; y < GRID_SIZE; y++) {
  for (let x = 0; x < GRID_SIZE; x++) {
    grid.push({
      x: x,
      y: y,
      color: '#FFFFFF' // default white
    })
  }
}

// Draw a pixel on the canvas
drawPixel = (x, y, color) => {
  ctx.fillStyle = color;
  ctx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
}

// Get pixel color at coordinates
function getPixelColor(x, y) {
  const userPixel = userPixels.find(p => p.x === x && p.y === y);
  if (userPixel) {
    return userPixel.color;
  }
  const gridPixel = grid.find(p => p.x === x && p.y === y);
  return gridPixel ? gridPixel.color : -1;
}

// Load from DataPantry on init
async function loadCanvas() {
  const res = await fetch('/api/load-pixels').then(r => r.json())
  console.log('Loaded pixel data:', res.pixels.length, 'records. Sample:', res.pixels.slice(0, 5));
  console.log('User wait time (seconds):', res.waitTime);
  res.pixels.forEach(pixel => {
    const index = grid.findIndex(p => p.x === pixel.x && p.y === pixel.y);
    if (index !== -1) {
      grid[index].color = pixel.color;
    }
  })
  timeout = res.waitTime || 0;

  updateCanvasTransform();
  redrawCanvas();
  startTimeoutTimer();
}

// Redraw entire canvas
function redrawCanvas() {
  grid.forEach(pixel => {
    drawPixel(pixel.x, pixel.y, pixel.color);
  });
}

// Function to update canvas transform
function updateCanvasTransform() {
  canvas.style.transform = `scale(${zoom})`;
  canvas.style.left = `${pan.x}px`;
  canvas.style.top = `${pan.y}px`;
}

window.addEventListener('wheel', (e) => {
  e.preventDefault();
  
  const oldZoom = zoom;
  zoom += e.deltaY * -0.001;
  zoom = Math.min(Math.max(1, zoom), 10);
  
  if (zoom === oldZoom) return; // No change, skip calculations
  
  // Get mouse position in viewport
  const mouseViewportX = e.clientX;
  const mouseViewportY = e.clientY;
  
  // Get canvas position in viewport BEFORE zoom
  const rect = canvas.getBoundingClientRect();
  
  // Calculate which point on the canvas (in canvas pixels) is under the mouse
  const canvasPointX = (mouseViewportX - rect.left) / oldZoom;
  const canvasPointY = (mouseViewportY - rect.top) / oldZoom;
  
  // After zoom, we want this same canvas point to be under the mouse
  // So we solve: mouseViewportX = (canvasPointX * zoom) + newCanvasLeft
  // Therefore: newCanvasLeft = mouseViewportX - (canvasPointX * zoom)
  const newCanvasLeft = mouseViewportX - (canvasPointX * zoom);
  const newCanvasTop = mouseViewportY - (canvasPointY * zoom);
  
  // Update pan (remember, pan.x/y are the left/top positions of the canvas)
  pan.x = newCanvasLeft;
  pan.y = newCanvasTop;
  
  updateCanvasTransform();
});

// Used for panning. To draw pixels, see click event
window.addEventListener('mousedown', (e) => {
  mousedown = true;
});

window.addEventListener('mouseup', (e) => {
  mousedown = false;
});

window.addEventListener('mouseleave', (e) => {
  mousedown = false;
});

function getPanLimits() {
  const canvasSize = 1000; // Your canvas width/height
  const viewportSize = Math.min(window.innerWidth, window.innerHeight);
  const scaledCanvasSize = canvasSize * zoom;
  
  // Allow panning 3x the canvas size
  const maxPan = Math.max(0, (scaledCanvasSize * 3 - viewportSize) / 2);
  
  return {
    x: maxPan,
    y: maxPan
  };
}

 //  Handle panning
window.addEventListener('mousemove', (e) => {
  if (mousedown) {
    let deltaX = e.clientX - previousMousePos.x;
    let deltaY = e.clientY - previousMousePos.y;
    const panLimits = getPanLimits();
    if (Math.abs(pan.x + deltaX) > panLimits.x) {
      deltaX = 0;
    }
    if (Math.abs(pan.y + deltaY) > panLimits.y) {
      deltaY = 0;
    }
    pan.x += deltaX;
    pan.y += deltaY;
    updateCanvasTransform();
    previousMousePos = { x: e.clientX, y: e.clientY };
    return; // Skip hover drawing while panning
  }
  previousMousePos = { x: e.clientX, y: e.clientY };
});

//  hover effect
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect()

  // Account for scaling when calculating pixel coordinates
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;

  //  x and y coord of the mouse (in pixels)
  const x = Math.floor(((e.clientX - rect.left) * scaleX) / PIXEL_SIZE);
  const y = Math.floor(((e.clientY - rect.top) * scaleY) / PIXEL_SIZE);
  
  //  Drawing the hover outline
  if (hoveredPixel?.x !== x || hoveredPixel?.y !== y) {

    // Redraw old hovered pixel (rfemove outline)
    let color = getPixelColor(x, y);
    if (hoveredPixel) {
      let userPixel = userPixels.find(p => p.x === hoveredPixel.x && p.y === hoveredPixel.y);
      if (userPixel) {
        drawPixel(hoveredPixel.x, hoveredPixel.y, userPixel.color)
      } else {
        let gridIndex = grid.findIndex(p => p.x === hoveredPixel.x && p.y === hoveredPixel.y);
        if (gridIndex === -1) return; // out of bounds
        drawPixel(hoveredPixel.x, hoveredPixel.y, grid[gridIndex].color)
      }
    }
    
    // Draw new hover outline
    hoveredPixel = { x, y }
    let gridIndex = grid.findIndex(p => p.x === x && p.y === y);
    if (gridIndex === -1) return; // out of bounds
    drawPixel(x, y, grid[gridIndex].color)
    ctx.strokeStyle = '#000000'
    ctx.lineWidth = 2
    ctx.strokeRect(x * PIXEL_SIZE + 1, y * PIXEL_SIZE + 1, PIXEL_SIZE-2, PIXEL_SIZE-2)
  }
})

// mouse out
canvas.addEventListener('mouseout', (e) => {
  if (hoveredPixel) {
    drawPixel(hoveredPixel.x, hoveredPixel.y, grid[hoveredPixel.y][hoveredPixel.x])
    hoveredPixel = null;
  }
});

//  draw on click
canvas.addEventListener('click', async (e) => {
  if (!hoveredPixel || totalPainted >= MAX_DRAW_PER_SESSION || timeout > 0) return;
  const { x, y } = hoveredPixel;
  userPixels.push({ x, y, color: selectedColor });
  drawPixel(x, y, selectedColor);
  totalPainted++;
  document.getElementById('saveButton').disabled = false;
  document.getElementById('saveButton').innerText = `Save ${totalPainted}/10 Pixels`;
  document.getElementById('cancelButton').style.display = 'flex';
});

// Start timeout timer
function startTimeoutTimer() {
  let countdown = setInterval(() => {
    timeout--;
    document.getElementById('cancelButton').style.display = 'none';
    if (timeout <= 0) {
      document.getElementById('saveButton').innerText = `Save 0/10 Pixels`;
      clearInterval(countdown);
      saved = false;
    } else {
      document.getElementById('saveButton').innerText = `${saved ? 'Saved!' : ''} Wait ${Math.floor(timeout / 60)}:${(timeout % 60).toString().padStart(2, '0')} min`;
    }
  }, 1000); // 1 second
}

// Save pixels to server
async function savePixels() {
  document.getElementById('saveButton').innerText = `Saving...`;
  document.getElementById('cancelButton').style.display = 'none';
  console.log('Saving pixels:', userPixels);
  timeout = 5 * 60; // 5 minutes in seconds
  const response = await fetch('/api/save-pixel', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      pixels: userPixels
    })
  });
  if (response.status !== 200) {
    const errorText = await response.text();
    alert(`Error saving pixels: ${errorText}`);
    document.getElementById('saveButton').innerText = `Save ${totalPainted}/10 Pixels`;
    return;
  }
  totalPainted = 0;
  document.getElementById('saveButton').innerText = `Saved! Wait 5:00 min`;
  document.getElementById('saveButton').disabled = true;
  saved = true;
  for (let i = 0; i < userPixels.length; i++) {
    const pixel = userPixels[i];
    const index = grid.findIndex(p => p.x === pixel.x && p.y === pixel.y);
    grid[index].color = pixel.color;
  }
  userPixels = [];
  startTimeoutTimer();
} 

function cancelPixels() {
  userPixels = [];
  totalPainted = 0;
  document.getElementById('saveButton').innerText = `Save 0/10 Pixels`;
  document.getElementById('saveButton').disabled = true;
  document.getElementById('cancelButton').style.display = 'none';
  redrawCanvas();
}

// Get an array of colors for the color options
function getColorArray() {
  const colors = [];
  for (let l = 0; l <= 100; l += 20) {   // 6 Grays
    colors.push(`hsl(0, 0%, ${l}%)`);
  }
  for (let h = 0; h < 360; h += 60) { //  6 Hues
    for (let s = 100; s >= 20; s -= 40) {  // 3 Saturations
      for (let l = 25; l <= 80; l += 25) {   // 3 Lightness
        colors.push(`hsl(${h}, ${s}%, ${l}%)`);
      }
    }
  }
  return colors;

}

function populateColorOptions() {
  const colorDisplay = document.getElementById('colorDisplay')
  colorDisplay.innerHTML = '' // clear existing
  const colors = getColorArray();
  colors.forEach(color => {
    const colorDiv = document.createElement('div')
    colorDiv.className = 'colorOption'
    colorDiv.className += (color === selectedColor) ? ' selected' : ''
    colorDiv.style.backgroundColor = color
    colorDiv.addEventListener('click', () => {
      selectedColor = color
      populateColorOptions() // refresh to show selected
    })

    colorDisplay.appendChild(colorDiv)
  })
}

function mount() {
  loadCanvas()
  redrawCanvas();
  populateColorOptions();
}
mount();
</script>
</html>