<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Pantry</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
      <!-- <h1>Welcome to Pixel Pantry</h1> -->
  </header>
  <main>
    <div id="toolbar">
      <label for="colorPicker">Choose Color:</label>
      <div id="colorDisplay"><!--  Color options added here  --></div>
    </div>
    <div id="infoIcon" onclick="toggleInfoBox(true)">
      i
    </div>
    <div id="infoBox">
      <h2>How to Use Pixel Pantry</h2>
      <ul>
        <li>Click on the canvas to place pixels (max 10 per session).</li>
        <li>Select your desired color from the color palette.</li>
        <li>Use mouse wheel or pinch gesture to zoom in/out.</li>
        <li>Click and drag (or use one finger on mobile) to pan around the canvas.</li>
        <li>After placing pixels, click "Save" to submit your changes.</li>
        <li>Wait time may apply between sessions.</li>
      </ul>
      <button onclick="toggleInfoBox(false)">Close</button>
    </div>
    <button id="saveButton" disabled onclick="savePixels()">Loading...</button>
    <button id="cancelButton" onclick="cancelPixels()" style="display: none;">
      &#10006;<!--  âœ–  -->
    </button>
    <canvas id="pixelCanvas"></canvas>
  </main>
</body>

<script>

const canvas = document.getElementById('pixelCanvas');
const ctx = canvas.getContext('2d');
canvas.width = 1000;
canvas.height = 1000;
const GRID_SIZE = 100;
const PIXEL_SIZE = canvas.width / GRID_SIZE;
const MAX_DRAW_PER_SESSION = 10;

let hoveredPixel = null; // Hover pixel tracking
let selectedColor = `hsl(0, 0%, 0%)`; // color to draw, default black
let totalPainted = 0; // Total pixels painted, out of 10 limit
let timeout = 0;
let userPixels = []; // pixels painted by user
let saved = false; // recently saved by the user
let zoom = 1;
let pan = {
  x: (window.innerWidth - canvas.width) / 2, // Start centered
  y: 0
};
let mousedown = false;
let previousMousePos = {
  x: 0,
  y: 0 
};
let touchStartDistance = null; // For pinch zoom
let touchStartZoom = null;
let touchStartPan = null;

// Initialize grid
let grid = [];
for (let y = 0; y < GRID_SIZE; y++) {
  for (let x = 0; x < GRID_SIZE; x++) {
    grid.push({
      x: x,
      y: y,
      color: '#FFFFFF' // default white
    })
  }
}

// Draw a pixel on the canvas
drawPixel = (x, y, color) => {
  ctx.fillStyle = color;
  ctx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
}

// Get pixel color at coordinates
function getPixelColor(x, y) {
  const userPixel = userPixels.find(p => p.x === x && p.y === y);
  if (userPixel) {
    return userPixel.color;
  }
  const gridPixel = grid.find(p => p.x === x && p.y === y);
  return gridPixel ? gridPixel.color : -1;
}

// Load from DataPantry on init
async function loadCanvas() {
  const res = await fetch('/api/load-pixels').then(r => r.json())
  console.log('Loaded pixel data:', res.pixels.length, 'records. Sample:', res.pixels.slice(0, 5));
  console.log('User wait time (seconds):', res.waitTime);
  res.pixels.forEach(pixel => {
    const index = grid.findIndex(p => p.x === pixel.x && p.y === pixel.y);
    if (index !== -1) {
      grid[index].color = pixel.color;
    }
  })
  timeout = res.waitTime || 0;

  updateCanvasTransform();
  redrawCanvas();
  startTimeoutTimer();
}

// Redraw entire canvas
function redrawCanvas() {
  grid.forEach(pixel => {
    drawPixel(pixel.x, pixel.y, pixel.color);
  });
}

// Function to update canvas transform
function updateCanvasTransform() {
  canvas.style.transform = `scale(${zoom})`;
  canvas.style.left = `${pan.x}px`;
  canvas.style.top = `${pan.y}px`;
}

window.addEventListener('wheel', (e) => {
  e.preventDefault();
  
  const oldZoom = zoom;
  zoom += e.deltaY * -0.001;
  zoom = Math.min(Math.max(1, zoom), 10);
  
  if (zoom === oldZoom) return; // No change, skip calculations
  
  // Get mouse position in viewport
  const mouseViewportX = e.clientX;
  const mouseViewportY = e.clientY;
  
  // Get canvas position in viewport BEFORE zoom
  const rect = canvas.getBoundingClientRect();
  
  // Calculate which point on the canvas (in canvas pixels) is under the mouse
  const canvasPointX = (mouseViewportX - rect.left) / oldZoom;
  const canvasPointY = (mouseViewportY - rect.top) / oldZoom;
  
  // After zoom, we want this same canvas point to be under the mouse
  // So we solve: mouseViewportX = (canvasPointX * zoom) + newCanvasLeft
  // Therefore: newCanvasLeft = mouseViewportX - (canvasPointX * zoom)
  const newCanvasLeft = mouseViewportX - (canvasPointX * zoom);
  const newCanvasTop = mouseViewportY - (canvasPointY * zoom);
  
  // Update pan (remember, pan.x/y are the left/top positions of the canvas)
  pan.x = newCanvasLeft;
  pan.y = newCanvasTop;
  
  updateCanvasTransform();
});

// Used for panning. To draw pixels, see click event
window.addEventListener('mousedown', (e) => {
  mousedown = true;
});

window.addEventListener('mouseup', (e) => {
  mousedown = false;
});

window.addEventListener('mouseleave', (e) => {
  mousedown = false;
});

function getPanLimits() {
  const canvasSize = 1000; // Your canvas width/height
  const viewportSize = Math.min(window.innerWidth, window.innerHeight);
  const scaledCanvasSize = canvasSize * zoom;
  
  // Allow panning 3x the canvas size
  const maxPan = Math.max(0, (scaledCanvasSize * 3 - viewportSize) / 2);
  
  return {
    x: maxPan,
    y: maxPan
  };
}

 //  Handle panning
window.addEventListener('mousemove', (e) => {
  if (mousedown) {
    let deltaX = e.clientX - previousMousePos.x;
    let deltaY = e.clientY - previousMousePos.y;
    const panLimits = getPanLimits();
    if (Math.abs(pan.x + deltaX) > panLimits.x) {
      deltaX = 0;
    }
    if (Math.abs(pan.y + deltaY) > panLimits.y) {
      deltaY = 0;
    }
    pan.x += deltaX;
    pan.y += deltaY;
    updateCanvasTransform();
    previousMousePos = { x: e.clientX, y: e.clientY };
    return; // Skip hover drawing while panning
  }
  previousMousePos = { x: e.clientX, y: e.clientY };
});

//  hover effect
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect()

  // Account for scaling when calculating pixel coordinates
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;

  //  x and y coord of the mouse (in pixels)
  const x = Math.floor(((e.clientX - rect.left) * scaleX) / PIXEL_SIZE);
  const y = Math.floor(((e.clientY - rect.top) * scaleY) / PIXEL_SIZE);
  
  //  Drawing the hover outline
  if (hoveredPixel?.x !== x || hoveredPixel?.y !== y) {

    // Redraw old hovered pixel (rfemove outline)
    let color = getPixelColor(x, y);
    if (hoveredPixel) {
      let userPixel = userPixels.find(p => p.x === hoveredPixel.x && p.y === hoveredPixel.y);
      if (userPixel) {
        drawPixel(hoveredPixel.x, hoveredPixel.y, userPixel.color)
      } else {
        let gridIndex = grid.findIndex(p => p.x === hoveredPixel.x && p.y === hoveredPixel.y);
        if (gridIndex === -1) return; // out of bounds
        drawPixel(hoveredPixel.x, hoveredPixel.y, grid[gridIndex].color)
      }
    }
    
    // Draw new hover outline
    hoveredPixel = { x, y }
    let gridIndex = grid.findIndex(p => p.x === x && p.y === y);
    if (gridIndex === -1) return; // out of bounds
    drawPixel(x, y, grid[gridIndex].color)
    ctx.strokeStyle = '#000000'
    ctx.lineWidth = 2
    ctx.strokeRect(x * PIXEL_SIZE + 1, y * PIXEL_SIZE + 1, PIXEL_SIZE-2, PIXEL_SIZE-2)
  }
})

// mouse out
canvas.addEventListener('mouseout', (e) => {
  if (hoveredPixel) {
    drawPixel(hoveredPixel.x, hoveredPixel.y, grid[hoveredPixel.y][hoveredPixel.x])
    hoveredPixel = null;
  }
});

//  draw on click
canvas.addEventListener('click', async (e) => {
  if (!hoveredPixel || totalPainted >= MAX_DRAW_PER_SESSION || timeout > 0) return;
  const { x, y } = hoveredPixel;
  userPixels.push({ x, y, color: selectedColor });
  drawPixel(x, y, selectedColor);
  totalPainted++;
  toggleInfoBox(false);
  document.getElementById('saveButton').disabled = false;
  document.getElementById('saveButton').innerText = `Save ${totalPainted}/10 Pixels`;
  document.getElementById('cancelButton').style.display = 'flex';
});

// Touch event handlers for mobile
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  
  if (e.touches.length === 1) {
    // Single finger - start panning
    mousedown = true;
    previousMousePos = {
      x: e.touches[0].clientX,
      y: e.touches[0].clientY
    };
  } else if (e.touches.length === 2) {
    // Two fingers - start pinch zoom
    mousedown = false;
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    touchStartDistance = Math.hypot(
      touch2.clientX - touch1.clientX,
      touch2.clientY - touch1.clientY
    );
    touchStartZoom = zoom;
    touchStartPan = { ...pan };
  }
});

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  
  if (e.touches.length === 1 && mousedown) {
    // Single finger - pan
    const touch = e.touches[0];
    const deltaX = touch.clientX - previousMousePos.x;
    const deltaY = touch.clientY - previousMousePos.y;
    
    pan.x += deltaX;
    pan.y += deltaY;
    
    previousMousePos = {
      x: touch.clientX,
      y: touch.clientY
    };
    
    updateCanvasTransform();
  } else if (e.touches.length === 2) {
    // Two fingers - pinch zoom
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    
    const currentDistance = Math.hypot(
      touch2.clientX - touch1.clientX,
      touch2.clientY - touch1.clientY
    );
    
    // Calculate center point between two fingers
    const centerX = (touch1.clientX + touch2.clientX) / 2;
    const centerY = (touch1.clientY + touch2.clientY) / 2;
    
    // Calculate new zoom
    const oldZoom = zoom;
    zoom = touchStartZoom * (currentDistance / touchStartDistance);
    zoom = Math.min(Math.max(1, zoom), 10);
    
    // Get canvas position before zoom
    const rect = canvas.getBoundingClientRect();
    
    // Calculate which point on canvas is at the pinch center
    const canvasPointX = (centerX - rect.left) / oldZoom;
    const canvasPointY = (centerY - rect.top) / oldZoom;
    
    // Adjust pan to keep the pinch center fixed
    pan.x = centerX - (canvasPointX * zoom);
    pan.y = centerY - (canvasPointY * zoom);
    
    updateCanvasTransform();
  }
});

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  
  if (e.touches.length === 0) {
    mousedown = false;
    touchStartDistance = null;
    touchStartZoom = null;
    touchStartPan = null;
  } else if (e.touches.length === 1) {
    // Went from 2 fingers to 1, restart panning
    mousedown = true;
    previousMousePos = {
      x: e.touches[0].clientX,
      y: e.touches[0].clientY
    };
    touchStartDistance = null;
  }
});

canvas.addEventListener('touchcancel', (e) => {
  mousedown = false;
  touchStartDistance = null;
  touchStartZoom = null;
  touchStartPan = null;
});

// Start timeout timer
function startTimeoutTimer() {
  let countdown = setInterval(() => {
    timeout--;
    document.getElementById('cancelButton').style.display = 'none';
    if (timeout <= 0) {
      document.getElementById('saveButton').innerText = `Save 0/10 Pixels`;
      clearInterval(countdown);
      saved = false;
    } else {
      document.getElementById('saveButton').innerText = `${saved ? 'Saved!' : ''} Wait ${Math.floor(timeout / 60)}:${(timeout % 60).toString().padStart(2, '0')} min`;
    }
  }, 1000); // 1 second
}

// Save pixels to server
async function savePixels() {
  document.getElementById('saveButton').innerText = `Saving...`;
  document.getElementById('cancelButton').style.display = 'none';
  console.log('Saving pixels:', userPixels);
  timeout = 5 * 60; // 5 minutes in seconds
  const response = await fetch('/api/save-pixel', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      pixels: userPixels
    })
  });
  if (response.status !== 200) {
    const errorText = await response.text();
    alert(`Error saving pixels: ${errorText}`);
    document.getElementById('saveButton').innerText = `Save ${totalPainted}/10 Pixels`;
    return;
  }
  totalPainted = 0;
  document.getElementById('saveButton').innerText = `Saved! Wait 5:00 min`;
  document.getElementById('saveButton').disabled = true;
  saved = true;
  for (let i = 0; i < userPixels.length; i++) {
    const pixel = userPixels[i];
    const index = grid.findIndex(p => p.x === pixel.x && p.y === pixel.y);
    grid[index].color = pixel.color;
  }
  userPixels = [];
  startTimeoutTimer();
} 

function cancelPixels() {
  userPixels = [];
  totalPainted = 0;
  document.getElementById('saveButton').innerText = `Save 0/10 Pixels`;
  document.getElementById('saveButton').disabled = true;
  document.getElementById('cancelButton').style.display = 'none';
  redrawCanvas();
}

// Get an array of colors for the color options
function getColorArray() {
  const colors = [];
  for (let l = 0; l <= 100; l += 20) {   // 6 Grays
    colors.push(`hsl(0, 0%, ${l}%)`);
  }
  for (let h = 0; h < 360; h += 60) { //  6 Hues
    for (let s = 100; s >= 20; s -= 40) {  // 3 Saturations
      for (let l = 25; l <= 80; l += 25) {   // 3 Lightness
        colors.push(`hsl(${h}, ${s}%, ${l}%)`);
      }
    }
  }
  return colors;

}

function populateColorOptions() {
  const colorDisplay = document.getElementById('colorDisplay')
  colorDisplay.innerHTML = '' // clear existing
  const colors = getColorArray();
  colors.forEach(color => {
    const colorDiv = document.createElement('div')
    colorDiv.className = 'colorOption'
    colorDiv.className += (color === selectedColor) ? ' selected' : ''
    colorDiv.style.backgroundColor = color
    colorDiv.addEventListener('click', () => {
      selectedColor = color
      populateColorOptions() // refresh to show selected
    })

    colorDisplay.appendChild(colorDiv)
  })
}

function toggleInfoBox(makeVisible = false) {
  document.getElementById('infoBox').style.display = makeVisible ? 'block' : 'none';
  document.getElementById('infoIcon').style.display = makeVisible ? 'none' : 'block';
}

function mount() {
  loadCanvas()
  redrawCanvas();
  populateColorOptions();
}
mount();
</script>
</html>